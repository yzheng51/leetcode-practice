# Container With Most Water

## 描述

给定 $n$ 个非负整数 $a_1, a_2, ..., a_n$，每个数代表坐标中的一个点 $(i, a_i)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, a_i)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 $n$ 的值至少为 $2$。

![alt text](/images/question_11.jpg)

图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
```

## 解法

此题可以通过循环固定左端点，遍历右端点来得到最终结果，算法复杂度为 $O(n^2)$。但是此算法超出了时间限制，仔细思考下发现有些情况是没有必要计算的。假设 `h[x]` 和 `h[y]` 分别是左右两端点，并且 `h[x]` 从 $a_1$ 开始，`h[y]` 从$a_n$ 开始。

- `h[x] < h[y]`

  此时水的高度为 `h[x]`，如果 `h[y-1]` 比 `h[x]` 大，由于高度还是 `h[x]` 而且长度 `y - x` 变小了，水的总面积变小。如果 `h[y-1]` 比 `h[x]` 小，高度变小，长度也变小，总面积还是变小。所以此时右端往左移并不能使最终面积变大，此时唯一选择就是将左端往右移

- `h[x] >= h[y]`

  同理，此时只能将右端往左移

上述解法相当于固定一端，只移动另一端，所以时间复杂度为 $O(n)$

## 代码

```cpp
class Solution {
public:
    int maxArea(std::vector<int> &height) {
        int i = 0;
        int j = height.size() - 1;
        int area = 0;
        while (i != j) {
            if (height[i] < height[j]) {
                area = std::max(area, height[i] * (j - i));
                ++i;
            } else {
                area = std::max(area, height[j] * (j - i));
                --j;
            }
        }
        return area;
    }
};
```
