# Divide Two Integers

## 描述

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

```
输入: dividend = 10, divisor = 3
输出: 3
```
```
输入: dividend = 7, divisor = -3
输出: -2
```
说明:

- 被除数和除数均为 `32` 位有符号整数。
- 除数不为 `0`。
- 假设我们的环境只能存储 `32` 位有符号整数，其数值范围是 $[−2^{31},  2^{31} − 1]$。本题中，如果除法结果溢出，则返回 $2^{31} − 1$。

## 解法

此题难点有两个，除法的二进制理解和整型溢出的处理。首先是除法的二进制理解，由于本题不允许使用高级运算符号，那么显然只能通过计算机底层的位运算来实现等价的功能。假设被除数是 `10` ，除数是 `3` ，那么
$$
3\times (2^{1}+2^{0})<10<3\times (2^{1}+2^{0})+\mathbf{3}
$$
那么商就是 $2^{1} + 2^{0} = 3$ 。在程序中我们可以通过循环的方式先找到最高次项 $3 \times 2^{1} < 10$ ，然后用被除数减去这个数得到 $10-3\times 2^{1}=4$ 然后再找到第二高次项 $3 \times 2^{0}<4$ ，以此类推直到被除数缩小到比除数小为止。最后将过程中得到的 $2$ 的指数项全加起来就能得到最终结果

因为在做这题时，考虑将被除数和除数都先转换为正数再进行上述操作，所以需要先对这两个数取绝对值。这里就会遇到整型溢出的问题

- 当被除数 `dividend` 是 $-2^{31}$
  1. 当除数是 $-2^{31}$ 时，为了避免处理将除数取绝对值，这里也直接输出 $1$
  2. 当除数是 $0$ 时，此时应抛出异常，这里将返回整型最大值作为替代
  3. 当除数是 $1$ 时，即由题设可知结果为 $2^{31} − 1$ ，但若归入第四种情况会得到 $2^{31}$ ，因此直接输出结果
  4. 当除数是其他数时，能正常取其绝对值。为避免被除数取绝对值的整型溢出问题，先用其正数部分减去除数，同时 `res` 的值初始化为 `1` 而非 `0` 。然后再将被除数取绝对值，此时就不会有溢出问题，然后按上述做法求出商
- 当除数 `divisor` 是 $-2^{31}$
  1. 当被除数是 $-2^{31}$ 时，直接输出 $1$
  2. 当被除数是其他数时，由于有整型的限制，其绝对值最大不会超过 $2^{31}-1$ ，所以结果必然为 $0$

除了对输入的处理，在找最高次项 `t` 的过程中，当被除数和除数满足一定条件使 `t` 能达到 $2^{30}\le t<2^{31}-1$ ，那么 `t << 1` 就会造成整型溢出。因此循环终止条件要加上 `t << 1 >= 0` 。最后输出前

## 代码

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (divisor == 0) {
            return INT_MAX;
        }
        if (divisor == 1) {
            return dividend;  // for INT_MIN / 1
        }
        if (divisor == -1) {
            return dividend == INT_MIN ? INT_MAX : -dividend;  // for INT_MIN / -1
        }

        if (divisor == INT_MIN) {
            return dividend == INT_MIN;  // for any / INT_MIN
        }
        int b = abs(divisor);
        int a = (dividend == INT_MIN) ? abs(dividend + b) : abs(dividend);
        int res = dividend == INT_MIN;
        while (a >= b) {
            int t = b;
            int m = 1;
            while (t << 1 > 0 && t << 1 <= a) {
                t <<= 1;
                m <<= 1;
            }
            a -= t;
            res += m;
        }
        return (dividend > 0 ^ divisor > 0) ? -res : res;
    }
};
```
