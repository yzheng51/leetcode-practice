# Ugly Number II

## 描述

编写一个程序，找出第 `n` 个丑数。

丑数就是只包含质因数 `2, 3, 5` 的正整数。

```plain
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

说明:

- `1` 是丑数。
- `n` 不超过 `1690`。

## 解法

求解该题的思路和求质数的埃拉托斯特尼筛法相似，通过前面丑数的 `2, 3, 5` 的倍数来判断是否为丑数。由于该题要求第 `n` 个丑数，稍稍思考下不难发现可以通过采用动态规划的思想来解决，假设 `dp[i]` 表示第 `i + 1` 个丑数，其中第一个丑数为 `1`，即 `dp[0] = 1`。根据丑数的定义，第二个数必然有
$$
dp[1]=\min\{2\times dp[0],3\times dp[0],5\times dp[0]\}=2\times dp[0]=2
$$
由于 $2\times dp[0]$ 已经存在与数组中了，下次计算时 $2$ 倍选项的数组下标应该往后移一位，即
$$
dp[2]=\min\{2\times dp[1],3\times dp[0],5\times dp[0]\}=3\times dp[0]=3
$$
该操作之后，$3$ 倍选项的数组下标也往后移动一位。到此，不难可以得出该动态规划的状态转移方程为
$$
dp[i]=\min\{2\times dp[t_2],3\times dp[t_3],5\times dp[t_5]\}
$$
其中 $t_k$ 为 $k$ 倍数被选择的次数，其初始值都为 `0`。该算法有一个注意点，当一个数同时能被 `2, 3, 5` 中的两个以上整除时，其相应的被选择次数都要自增。比如
$$
2\times dp[2]=3\times dp[1]
$$
等号左右两边都是 $6$，如果计算 $3\times dp[1]$ 的时候不把 $2$ 倍数被选择的次数加一，会导致下一个数也是 $6$。最后加上边界条件的判断，代码如下

## 代码

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        if (n <= 0) {
            return 0;
        }
        std::vector<int> dp(n);
        int t2 = 0, t3 = 0, t5 = 0;
        dp[0] = 1;
        for (int i = 1; i < n; ++i) {
            dp[i] = std::min(2 * dp[t2], std::min(3 * dp[t3], 5 * dp[t5]));
            if (dp[i] == 2 * dp[t2]) {
                ++t2;
            }
            if (dp[i] == 3 * dp[t3]) {
                ++t3;
            }
            if (dp[i] == 5 * dp[t5]) {
                ++t5;
            }
        }
        return dp[n - 1];
    }
};
```
